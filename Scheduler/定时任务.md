### Schedule

#### 简介



#### 入门

1. 安装依赖

   ```xml
   <dependency>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-quartz</artifactId>
   </dependency>
   ```

2. 编写任务类

   ```java
   @Component
   public class ScheduleTask {
   
       private final Logger log = LoggerFactory.getLogger(ScheduleTask.class);
   
       @Scheduled(cron = "1/2 * * * * ?")
       public void task1() throws InterruptedException {
           log.info("task-1, 我需要执行10秒的时间, 线程Id：{}， 线程名：{}，时间：{}",
                   Thread.currentThread().getId(), Thread.currentThread().getName(), LocalDateTime.now());
           Thread.sleep(10000);
           log.error("task-1 ending....., 线程Id：{}， 线程名：{}，时间：{}",
                   Thread.currentThread().getId(), Thread.currentThread().getName(), LocalDateTime.now());
       }
   }
   ```

3. 配置主启动类

   ```java
   @SpringBootApplication
   // 开启定时任务功能
   @EnableScheduling
   public class SchedulerApplication {
       public static void main(String[] args) {
           SpringApplication.run(SchedulerApplication.class, args);
       }
   }
   ```

4. 启动运行

![1603365311704](D:\github\SpringBoot-Learning\Scheduler\doc\image\1603365311704.png)



 **@Scheduled** 

#### 多任务并发执行

现在再添加一个定时任务，测试当跑多个定时任务

```java
@Scheduled(cron = "1/4 * * * * ?")
public void task2() throws InterruptedException {
    log.info("task-2, 我需要执行两秒时间, 线程Id：{}， 线程名：{}，时间：{}",
             Thread.currentThread().getId(), Thread.currentThread().getName(), LocalDateTime.now());
    Thread.sleep(2000);
    log.error("task-2 ending....., 线程Id：{}， 线程名：{}，时间：{}",
              Thread.currentThread().getId(), Thread.currentThread().getName(), LocalDateTime.now());
}
```

执行结果

![1603365523575](D:\github\SpringBoot-Learning\Scheduler\doc\image\1603365523575.png)

可以发现两个任务是串行执行的，其他任务必须等到另一任务执行完成才能执行

默认情况下，Spring Boot将仅使用一个线程来运行所有计划的任务



创建了一个新的配置类，该类扩展了*SchedulingConfigurer*。能够配置任务计划程序，并传入我们要使用的线程池大小 ，

```java
@Configuration
public class SchedulerConfig implements SchedulingConfigurer {

    private int corePoolSize = 10;
    private String threadNamePrefix = "scheduled-task-pool-";

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        ThreadPoolTaskScheduler executor = new ThreadPoolTaskScheduler();
        executor.setPoolSize(corePoolSize);
        executor.setThreadNamePrefix(threadNamePrefix);
        executor.initialize();

        taskRegistrar.setScheduler(executor);
    }
}
```

配置完成，执行可以发现两个定时任务可以并发执行

![1603365842220](D:\github\SpringBoot-Learning\Scheduler\doc\image\1603365842220.png)



#### 动态配置执行时间

之前的执行时间都是写死在代码中的，现在通过数据库动态配置执行时间







#### 结合Calender使用